<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="一、jvm题目1、java的内存模型线程私有：程序计数器，虚拟机栈，本地方法栈 线程共享：堆，方法区 程序计数器： 当前线程所执行字节码的行号指示器。没有定义异常。 虚拟机栈： java方法执行的内存模型，每一个java方法在执行的时候都会创建一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的基本类型和引用类型，局部变量表所需的内存空间在编译期间分配完成，">
<meta property="og:type" content="article">
<meta property="og:title" content="java总结">
<meta property="og:url" content="http://yoursite.com/2018/12/07/java总结/index.html">
<meta property="og:site_name" content="日暮途远的博客">
<meta property="og:description" content="一、jvm题目1、java的内存模型线程私有：程序计数器，虚拟机栈，本地方法栈 线程共享：堆，方法区 程序计数器： 当前线程所执行字节码的行号指示器。没有定义异常。 虚拟机栈： java方法执行的内存模型，每一个java方法在执行的时候都会创建一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的基本类型和引用类型，局部变量表所需的内存空间在编译期间分配完成，">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-12-07T09:06:27.254Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java总结">
<meta name="twitter:description" content="一、jvm题目1、java的内存模型线程私有：程序计数器，虚拟机栈，本地方法栈 线程共享：堆，方法区 程序计数器： 当前线程所执行字节码的行号指示器。没有定义异常。 虚拟机栈： java方法执行的内存模型，每一个java方法在执行的时候都会创建一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的基本类型和引用类型，局部变量表所需的内存空间在编译期间分配完成，">
  <link rel="canonical" href="http://yoursite.com/2018/12/07/java总结/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>java总结 | 日暮途远的博客</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">日暮途远的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/07/java总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭世雄">
      <meta itemprop="description" content="人生但苦无妨，良人当归即好">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日暮途远的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">java总结

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-12-07 16:16:59 / 修改时间：17:06:27" itemprop="dateCreated datePublished" datetime="2018-12-07T16:16:59+08:00">2018-12-07</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一、jvm题目"><a href="#一、jvm题目" class="headerlink" title="一、jvm题目"></a>一、jvm题目</h1><h2 id="1、java的内存模型"><a href="#1、java的内存模型" class="headerlink" title="1、java的内存模型"></a>1、java的内存模型</h2><p>线程私有：程序计数器，虚拟机栈，本地方法栈</p>
<p>线程共享：堆，方法区</p>
<p><strong>程序计数器：</strong> 当前线程所执行字节码的行号指示器。没有定义异常。</p>
<p><strong>虚拟机栈：</strong> java方法执行的内存模型，每一个java方法在执行的时候都会创建一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的基本类型和引用类型，局部变量表所需的内存空间在编译期间分配完成，运行期间不会改变大小。操作数栈中存放指令执行时所需要的操作数；动态链接：每个栈帧中都包含一个该栈帧所属方法的引用；方法出口：每一个方法结束无非是正常return或者抛出了Exception并且没有catch语句，在方法执行完之后需要返回到方法被调用的位置，返回时需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。可能抛出StackOverflowError或OutOfMemoryError</p>
<p><strong>本地方法栈：</strong> 为native方法服务。可能抛出StackOverflowError或OutOfMemoryError</p>
<p><strong>堆：</strong> 虚拟机所管理内存中最大的一块，在虚拟机启动时创建，用于存放对象实例和数组，从垃圾回收的角度看分为新生代、老年代；再细致可分为Eden、FromSurvivor、ToSurvivor空间、老年代。可能出现OutOfMemoryError</p>
<p><strong>方法区：</strong> 用来存储虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据。垃圾回收的对象为：常量池的回收和类型的卸载。可能出现</p>
<p>OutOfMemoryError。</p>
<p><strong>运行时常量池(方法区的一部分)：</strong>用来存放编译期生成的各种字面量（文本字符串、声明为final的常量）和符号引用（类的全限定名、字段和方法的名称和描述符）</p>
<p>还有一块不属于虚拟机运行时数据区的一部分为直接内存：例如nio中使用native函数库直接分配堆外内存，然后通过堆内的引用直接操作这块内存，避免了java堆和native堆的来回复制，可能抛出OutOfMemory异常</p>
<p>与垃圾回收相关的JVM参数：</p>
<p>-Xms/-Xmx堆的初始大小/堆的最大大小</p>
<p>-Xss栈的大小</p>
<p>-Xmn堆中年轻代的大小</p>
<p>-XX:-DisableExplicitGC让System.gc()不产生任何作用</p>
<p>-XX:+PrintGCDetails打印GC的细节</p>
<p>-XX:+PrintGCDateStamps打印GC操作的时间戳</p>
<p>-XX:NewSize/XX:MaxNewSize设置新生代大小/新生代最大大小</p>
<p>-XX:NewRatio可以设置老生代和新生代的比例</p>
<p>-XX:PrintTenuringDistribution设置每次新生代GC后输出幸存者乐园中对象年龄的分布</p>
<p>-XX:InitialTenuringThreshold/-XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值</p>
<p>-XX:TargetSurvivorRatio：设置幸存区的目标使用率</p>
<h2 id="2、类加载的过程"><a href="#2、类加载的过程" class="headerlink" title="2、类加载的过程"></a>2、类加载的过程</h2><p>初始化的五种情况：</p>
<p>1.遇到new、getStatic、putStatic、invokeStatic这四条字节码指令时</p>
<p>2.对类进行反射调用时，该类未初始化</p>
<p>3.初始化一个类时，其父类若没有初始化则先初始化其父类（接口除外）</p>
<p>4.Main()函数所在的类</p>
<p>5.Jdk1.7中的动态语言的支持</p>
<p>以上称为对类的主动引用，被动引用不会引发初始化：</p>
<p>1.通过子类引用父类的静态字段</p>
<p>2.通过数组定义来引用类</p>
<p>3.引用类的常量（finalstatic的变量会在编译的时候存入常量池）</p>
<p><strong>加载：</strong> 通过类的全限定名加载二进制字节流；将这个流所代表的静态存储结构转化为方法区的运行时数据结构；在方法区中生成一个代表这个类的Class对象</p>
<p><strong>验证：</strong> 确保class文件中的字节流中的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全：文件格式验证、元数据验证、字节码验证、符号引用验证</p>
<p><strong>准备：</strong> 为类变量分配内存并设置类变量初始零值</p>
<p><strong>解析：</strong> 将常量池中的符号引用替换为直接引用。这一阶段会根据需要发生在初始化之前或之后，包含类或接口解析、字段解析、方法解析符号引用是无关虚拟机实现的内存布局。直接引用是和虚拟机实现的内存布局相关的。符号引用必须在运行期转换获得真正的内存入口地址</p>
<p><strong>初始化：</strong> 执行\&lt;clinit\&gt;方法，该方法由编译器自动按书写顺序收集类中所有的类变量的赋值动作和静态语句块中的语句合并而成。</p>
<p>new一个类时：父类静态、子类静态、父类成员域、父类构造代码块、父类构造方法、子类成员域、子类构造代码块、子类构造方法</p>
<h2 id="3、对象创建方法，对象的内存布局，对象的访问定位"><a href="#3、对象创建方法，对象的内存布局，对象的访问定位" class="headerlink" title="3、对象创建方法，对象的内存布局，对象的访问定位"></a>3、对象创建方法，对象的内存布局，对象的访问定位</h2><p>对象的创建：</p>
<ol>
<li>当虚拟机遇到一条new指令时，首先检查这个指令的参数能否在常量池中定位到这个类的符号引用，并检查这个类是否已经被加载、解析、初始化过。如果没有必须进行类加载过程</li>
<li>为新生对象分配内存，通过指针碰撞或者空闲列表法。为了解决并发问题可以采用TLAB本地线程分配缓冲策略</li>
<li>初始化为对应类型的零值</li>
<li>在虚拟机对对象进行设置之后，执行\&lt;init\&gt;方法按照程序员的意图初始化</li>
</ol>
<p>对象内存布局：</p>
<p>对象在内存中的存储布局可以分为:对象头、实例数据、对齐填充对象头中存放：对象自身运行时数据、指向类元数据的指针</p>
<p>对象的访问定位：</p>
<p>使用句柄和直接指针两种方式</p>
<h2 id="4、双亲委派模型"><a href="#4、双亲委派模型" class="headerlink" title="4、双亲委派模型"></a>4、双亲委派模型</h2><p>类加载器通过组合的方式建立的父子关系，称为双亲委派模型。</p>
<p>类需要由加载它的类加载器和类本身一同确立其在虚拟机中的唯一性。</p>
<p><strong>BootstrapClassLoader：</strong> 负责加载JAVAHOME/lib目录下，或者被-XbootclassPath参数所指定的路径中的类库</p>
<p><strong>ExtensionClassLoader：</strong> 负责加载JAVAHOME/lib/ext目录下或者被java.ext.dirs系统变量所指定的路径中的所有类库</p>
<p><strong>ApplicationClassLoader：</strong> 是ClassLoader.getSystemClassLoader()方法的返回值，负责加载用户类路径上所指定的类库</p>
<p>工作过程：</p>
<p>一个类加载器收到了类加载的请求，它首先不会尝试自己加载这个类而是把这个请求委派给父加载器去完成。只有当父加载器反馈自己无法完成这个请求时，子加载器才会尝试自己去加载。</p>
<p>作用：</p>
<p>Java类随着它的类加载器一起具备了一种带有优先级的层级关系，比如Object这个类，无论哪个类加载它最终都是委派到bootstrapClassLoader去加载。保证了java程序的稳定运行。</p>
<h2 id="5、静态分派与动态分派"><a href="#5、静态分派与动态分派" class="headerlink" title="5、静态分派与动态分派"></a>5、静态分派与动态分派</h2><p>静态分派：</p>
<p>依赖静态类型来定位方法执行版本的分派动作称为静态分派，典型应用是Overload。在方法接收者（执行方的所有者）已经确定的情况下，使用哪个重载版本在编译阶段就已经确定。实际类型的变化在运行期才能确定。</p>
<p>动态分派：</p>
<p>在运行期依靠实际类型决定确定发放执行版本的分派过程称为动态分派，典型的应用是Override。实现的关键是invokevirtual指令：找到引用所指向的实际类型记作C，如果在类型C中找到了与目标方法特征签名都相同的方法并通过访问权限校验直接调用，若不通过则一次查找其父类中的方法，如果始终没有找到则抛出AbstractMethodError异常</p>
<h2 id="6、GC的两种判定方法"><a href="#6、GC的两种判定方法" class="headerlink" title="6、GC的两种判定方法"></a>6、GC的两种判定方法</h2><p>引用计数法：</p>
<p>在对象中添加一个引用计数器，每一个地方引用它值加1，当引用失效时值减1。很难解决对象间互相循环引用的问题。</p>
<p>可达性分析算法：</p>
<p>一个对象到GCRoots不可达就会判定为可回收对象</p>
<p>GCRoots包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中引用的对象。如果一个对象与GCRoots不可达时，将会被第一次标记并筛选判断是否有必要执行finalize()方法，有必要执行的进入F-QUEUE队列，稍后虚拟机将自动建立一个低优先级的线程去执行它。稍后虚拟机将进行二次标记：在finalize()方法中建立了与GCRoots的通路，仍然可以存活</p>
<h2 id="7、java引用都有哪几类"><a href="#7、java引用都有哪几类" class="headerlink" title="7、java引用都有哪几类"></a>7、java引用都有哪几类</h2><p><strong>强引用：</strong> 类似Obo=newOb();永远不会回收强引用引用的对象</p>
<p><strong>软引用：</strong> 只有在内存不足时(将发生异常前)，才会被回收。用来实现缓存</p>
<p><strong>弱引用：</strong> 下一次垃圾回收就会被回收。Util包中的WeakHashMap就使用了弱引用。它的key都被封装成弱引用，一旦强引用被删除，这个弱引用就会在下一次被回收。用来解约内存空间。</p>
<p><strong>虚引用：</strong> 不会对垃圾回收时间产生影响，这个对象被回收时，系统会受到一个通知。在创建虚引用的时候必须传入一个引用队列。</p>
<p>ReferenceQueue：我们可以声明虚引用来引用我们感兴趣的对象，在gc要回收的时候，gc收集器如果发现它还有虚引用会把这个虚引用添加到referenceQueue，这样我们如果检测到referenceQueue中有我们感兴趣的对象的时候，说明gc将要回收这个对象了。此时我们可以在gc回收之前做一些其他事情，比如记录些日志什么的。</p>
<p>ReferenceQueuerefQueue=newReferenceQueue();</p>
<p>DigitalCounterdigit=newDigitalCounter();</p>
<p>PhantomReference\&lt;DigitalCounter\&gt;phantom=newPhantomReference\&lt;DigitalCounter\&gt;(digit,refQueue);</p>
<h2 id="8、堆里面的分区各自特点"><a href="#8、堆里面的分区各自特点" class="headerlink" title="8、堆里面的分区各自特点"></a>8、堆里面的分区各自特点</h2><p>分区：Eden、fromsurvival、tosurvival、老年代</p>
<p>Eden区</p>
<p>位于Java堆的新生代。新生代中的对象寿命较短。大多数情况下对象有现在Eden区分配，如果启动了TLAB（本地线程分配缓冲）则优先在TLAB上分配。如果Eden区内存也用完了，则会进行一次MinorGC。</p>
<p>Survival区</p>
<p>复制算法将内存分为Eden、fromsurival、tosurvival三个区域，使用的时候每次只使用Eden和fromsurvival区域，当回收时将Eden和fromsurvival区中的活着的对象复制到tosurvival区上。</p>
<p>老年代</p>
<p>里存放的都是存活时间较久的，大小较大的对象：</p>
<p>大量连续内存空间的大对象直接进入老年代、长期存活的对象将进入老年代。</p>
<p>当老年代容量满的时候，会触发一次FullGC，回收年老代和年轻代中不再被使用的对象资源。</p>
<h2 id="9、常见垃圾收回算法"><a href="#9、常见垃圾收回算法" class="headerlink" title="9、常见垃圾收回算法"></a>9、常见垃圾收回算法</h2><p><strong>标记清扫法：</strong> 首先标记处所有需要回收的对象，然后统一回收，老年代</p>
<p><strong>复制算法：</strong> 将内存划分为大小相等的两块，每次只使用其中的一块，当块用完了，就把还活着的对象复制到另一块上，然后把已使用的那块一次清理。新生代的收集都采用复制算法</p>
<p><strong>标记整理法：</strong> 先标记需要回收的对象，然后让所有存活的对象都向一端移动，老年代</p>
<h2 id="10、GC收集器有哪些？CMS收集器与G1收集器的特点？如果让你优化收集方法，有什么思路？"><a href="#10、GC收集器有哪些？CMS收集器与G1收集器的特点？如果让你优化收集方法，有什么思路？" class="headerlink" title="10、GC收集器有哪些？CMS收集器与G1收集器的特点？如果让你优化收集方法，有什么思路？"></a>10、GC收集器有哪些？CMS收集器与G1收集器的特点？如果让你优化收集方法，有什么思路？</h2><p>新生代收集器：Serial（单线程）、ParNew（多线程）</p>
<p>老年代：CMS（标记清扫）、SerialOld（标记整理）、ParallelOld</p>
<p>Jdk1.7：G1收集器（标记整理）</p>
<p><strong>CMS收集器：</strong> 是一种以获取最短回收停顿时间为目标的收集器。基于标记清除算法实现，整个过程分为以下4个步骤：</p>
<p>（1）初始标记：仅仅只标记一下GCRoots能直接关联的对象，速度很快；</p>
<p>（2）并发标记：进行GCRootsTracing；</p>
<p>（3）重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记时间稍长，但远比并发标记短。</p>
<p>（4）并发清除；耗时最长的并发标记和并发清除都可以和用户线程一起工作。</p>
<p>有如下缺点：</p>
<p>（1）CMS收集器对CPU资源非常敏感</p>
<p>（2）无法处理浮动垃圾，可能出现ConcurrentModeFailure失败而导致另一次的FullGC。由于CMS并发清理阶段用户线程还在运行，伴随程序运行自然就会有新的垃圾不断产生，CMS无法在当次收集中处理掉他们，只好留待下一次GC时再清理。所以需要预留一部分空间存储这部分垃圾，当预留的内存无法满足程序需求，就会出现一次ConcurrentModeFailure失败。</p>
<p>（3）标记清除算法将会产生大量空间碎片。</p>
<p>G1收集器：</p>
<p>（1）并行与并发：G1能充分利用多CPU、多核环境下的硬件优势</p>
<p>（2）分代收集：采用不同的方式处理新建对象和已存活对象</p>
<p>（3）空间整合：基于标记整理算法实现，不会产生空间碎片</p>
<p>（4）可预测停顿：G1除了追求低停顿外，还能建立可预测的时间停顿模型</p>
<p>G1将整个Java堆分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离了，它们都是一部分Region的集合。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许收集的时间，优先回收价值最大的Region。</p>
<p>G1使用RememberedSet来避免全堆扫描，G1中每个Region都有一个与之对应的RememberedSet，当一个对象被引用时就会把相关引用信息记录到被引用对象所属的Region的RememberedSet之中，在进行垃圾回收时，就不会进行全堆扫描。</p>
<p>步骤：</p>
<p>（1）初始标记：仅仅只标记一下GCRoots能直接关联的对象，耗时很短</p>
<p>（2）并发标记：从GCRoot开始对堆中对象进行可达性分析，找出存活的对象，耗时较长，但可与用户线程并发执行。</p>
<p>（3）最终标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，更新RememberedSet</p>
<p>（4）筛选回收：对Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划</p>
<p>优化思路：</p>
<p>因为已经使用了标记-整理算法，所以应该从停顿时间上进行优化</p>
<h2 id="11、MinorGC与FullGC的触发机制"><a href="#11、MinorGC与FullGC的触发机制" class="headerlink" title="11、MinorGC与FullGC的触发机制"></a>11、MinorGC与FullGC的触发机制</h2><p><strong>MinorGC(新生代GC)：</strong> 大多数情况，对象在新生代Eden区中分配，当Eden区中没有足够的空间，虚拟机触发一次MinorGC。MinorGC非常频繁、速度快。</p>
<p>FullGC（老年代GC））：</p>
<p>1、MinorGC之前会先检查老年代中最大可用连续空间是否大于新生代中的对象，如果成立，则这次MinorGC是安全的。否则就要查看是否允许担保失败，如果不允许则改为进行FullGC,允许的话就尝试进行一次MinorGC；</p>
<p>2、此外当老年代容量满的时候，也会触发一次fullGC</p>
<h2 id="12、几种常用的内存调试工具：jmap、jstack、jconsole"><a href="#12、几种常用的内存调试工具：jmap、jstack、jconsole" class="headerlink" title="12、几种常用的内存调试工具：jmap、jstack、jconsole"></a>12、几种常用的内存调试工具：jmap、jstack、jconsole</h2><p><strong>1、jps：</strong> 输出JVM中运行的进程状态信息</p>
<p>jps[options][hostid]</p>
<p>如果不指定hostid就默认为当前主机或者服务器</p>
<p>参数说明：</p>
<p>-q：不输出类名、Jar名和传出main方法的参数</p>
<p>-m：输出传入main方法的参数</p>
<p>-l：输出main类和Jar全限定名</p>
<p>-v：输出传入JVM的参数</p>
<p><strong>2、jstack：</strong> 查看某个Java进程内的线程堆栈信息</p>
<p>jstack[option]pid</p>
<p>参数说明：</p>
<p>-l：longlistings，会打印出额外的锁信息，在发生死锁时可以用jstack–lpid来观察锁持有情况</p>
<p>-m：mixedmod，不仅会输出java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</p>
<p>jstack可以定位到线程堆栈，根据堆栈信息可以定位到具体代码。</p>
<p>ps–ef或者psaux查看进程</p>
<p>ps–Lfppid或者top–Hppid找出该进程内最耗费cpu的线程</p>
<p><strong>3、map(MemoryMap)和jhat(JavaHeapAnalysisTool)：</strong> jmap用来查看堆内存使用情况，一般结合jhat使用。</p>
<p>jmap[option]pid</p>
<p>如果运行在64位JVM上，可能需要指定-J-d64命令选项参数.</p>
<p><strong>4、Console：</strong> 一个内置Java性能分析器</p>
<p><strong>5、statJVM：</strong> 计监测工具</p>
<h2 id="13、System-gc方法有什么用"><a href="#13、System-gc方法有什么用" class="headerlink" title="13、System.gc方法有什么用"></a>13、System.gc方法有什么用</h2><p>希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。</p>
<h2 id="14、Object-finalize方法有什么用"><a href="#14、Object-finalize方法有什么用" class="headerlink" title="14、Object.finalize方法有什么用"></a>14、Object.finalize方法有什么用</h2><p>1、finalize()是由JVM自动调用的，JVM感觉内存空间有限时，才会开始执行finalize()。</p>
<p>2、gc只能清除在堆上分配的内存，而finalize回收在栈上面分配的内存。</p>
<p>3、finalize()方法是对象逃脱死亡命运的最后一次机会，而且任何一个对象的finalize()方法都只会被系统调用一次。</p>
<h1 id="二、javaSE题目"><a href="#二、javaSE题目" class="headerlink" title="二、javaSE题目"></a>二、javaSE题目</h1><h2 id="1、jdk1-7与jdk1-8的新特性"><a href="#1、jdk1-7与jdk1-8的新特性" class="headerlink" title="1、jdk1.7与jdk1.8的新特性"></a>1、jdk1.7与jdk1.8的新特性</h2><p>1.7</p>
<p>1、switch语法支持String</p>
<p>2、可以直接使用0b开头表示二进制变量</p>
<p>3、try-with-resource语句用于生命资源，保证资源在程序结束后关闭</p>
<p>4、catch多个异常</p>
<p>5、数字类型的下划线表示方式</p>
<p>1.8</p>
<p>1、允许给接口添加default的方法的实现</p>
<p>2、lambda表达式</p>
<p>3、函数式接口</p>
<p>4、关于日期处理在java.time包下有了新的api</p>
<h2 id="2、基本类型与包装类、基本类型的运算"><a href="#2、基本类型与包装类、基本类型的运算" class="headerlink" title="2、基本类型与包装类、基本类型的运算"></a>2、基本类型与包装类、基本类型的运算</h2><table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>长度（位）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>1</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>Integer是一个不可变对象，自动装箱和拆箱是由编译器来完成的。</p>
<p>1、newInteger(i)与Integer.valueof(i)方法的区别：</p>
<p>构造方法产生一个新的Integer对象，valueOf()方法有可能通过缓存经常请求的值而显著提高空间和时间性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中IntegerCache.high值默认为127，可以通过虚拟机参数AutoBoxCacheMax自定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integerc = <span class="number">1</span>;   <span class="comment">//这是自动装箱，编译器调用valueOf(1)方法</span></span><br><span class="line">Integerd = <span class="number">1</span>;</span><br><span class="line">System.out.println(c == d); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>2、自动包装机制的好处：</p>
<p>节省了常用数值的内存开销和创建对象的开销，提高了效率。</p>
<p>（1）Integer和int之间可以进行各种比较：Integer对象将自动拆箱后与int值比较。</p>
<p>（2）两个Integer对象之间也可以用\&gt;、\&lt;符号比较大小：两个Integer对象都拆箱后，在比较大小，但是两个Integer对象最好不要用==比较，因为-128~127范围内是取缓存内对象，所以相等，该范围外是两个不同对象引用比较，所以不等。</p>
<p>3、其他基本类型的包装机制</p>
<p>Byte、Short、Long对应的是-128~127</p>
<p>Character对应的是0~127</p>
<p>Float和Double没有自动装箱池</p>
<p>4、基本类型的运算</p>
<p>（1）在将float、double类型转换为int类型的时候总是截尾，如果想象四舍五入可以+0.5后强转，或者使用Math.round()方法。</p>
<p>Math.floor()取下整，Math.ceil()取上整。</p>
<p>（2）char、byte、short在运算之前会自动转换为int类型，结果自然也就是int类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;<span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">short</span> s = a + b;<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">short</span> s =<span class="number">2</span> + <span class="number">3</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>包装类的equals()方法会取值进行比较</p>
<h2 id="3、switch是否能作用在byte、long、String上？"><a href="#3、switch是否能作用在byte、long、String上？" class="headerlink" title="3、switch是否能作用在byte、long、String上？"></a>3、switch是否能作用在byte、long、String上？</h2><p>在Java5以前，switch(expr)中，expr只能是byte、short、char、int。从Java5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
<h2 id="4、String、StringBuffer、StringBuilder"><a href="#4、String、StringBuffer、StringBuilder" class="headerlink" title="4、String、StringBuffer、StringBuilder"></a>4、String、StringBuffer、StringBuilder</h2><p>StringBuffer是线程安全的</p>
<p>String对象是不可变的，当需要改变它的内容的时候会返回一个新的对象</p>
<p>StringBuffer、StringBuilder是变量</p>
<p>三者在执行速度上：StringBuilder\&gt;StringBuffer\&gt;String</p>
<p>String对+运算符的重载实际上是使用StringBuilder.append()创建了一个新的String对象</p>
<p>String为什么设计成不可变对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>
<p>包含两个成员变量：value[]：String的字符序列，hash：该String对象的hash值的缓存。我们通过普通代码对一个String的改变都是通过返回一个新的String对象来完成的。但是String也不是绝对不可变的，我们可以通过反射拿到value对象，然后改变它。（final域是不能修改的，但是如果final域指向的对象内的域是可变的话，我们就可以修改final域指向对象的内容）</p>
<p>设计成不可变的好处</p>
<p>1、因为它是不可变的，所以其hashCode()永远保持一致，也就是每次在使用一个String对象的hashCode的时候都不用重新计算，直接返回hash值即可，效率更高</p>
<p>2、不可变对象天生线程安全，可以无需同步的在多个线程间共享</p>
<p>3、安全性，常用于数据库连接、网络连接、打开文件等，避免了参数修改</p>
<h2 id="5、常见String比较，intern"><a href="#5、常见String比较，intern" class="headerlink" title="5、常见String比较，intern()"></a>5、常见String比较，intern()</h2><p>1、new出来的对象引用永远指向堆内存，String.intern()返回对应pool中的对象</p>
<p>2、Strings1=&quot;dsfsadf&quot;;这种字面量写法直接返回pool中的对象</p>
<p>3、Strings2=&quot;dsafd&quot;+s1;指向堆，只有+左右都是&quot;&quot;字面量才返回pool中。</p>
<p>4、String.intern()返回字符串对象的规范化表示形式。一个初始时为空的字符串池，它由类String私有地维护。String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。记录首次出现的实例</p>
<h2 id="6、请描述抽象类和接口的区别"><a href="#6、请描述抽象类和接口的区别" class="headerlink" title="6、请描述抽象类和接口的区别"></a>6、请描述抽象类和接口的区别</h2><p>1、抽象类的域没有特殊限制，接口的域自动为publicstaticfinal的，在声明的同时必须初始化</p>
<p>2、接口中定义的方法必须（自动为）是publicabstract的，抽象类中的抽象方法可以是默认类型或者public类型或者protected类型</p>
<p>3、Implements一个接口必须override所有方法，extends一个抽象类则只要override抽象方法。一个类只能继承一个类（抽象类），但是可以实现多个接口</p>
<p>4、从选择上来讲，当所表达的意思是某些事物的共性的时候最好使用接口，而当表达的意思是某一个具体的事物的时候就用抽象类</p>
<h2 id="7、内部类"><a href="#7、内部类" class="headerlink" title="7、内部类"></a>7、内部类</h2><p><strong>使用场景：</strong> 只考虑为它的外部类提供服务</p>
<p>每个内部类都能够独立的实现接口或者继承类</p>
<p><strong>成员内部类：</strong> 可以无条件访问外部类的所有成员属性和成员方法（包括private）。当成员内部类的field或method与外部类相同时默认访问的是内部类。每个实例都包含一个指向外围实例的引用，如果需要访问外围实例可使用outer.this.fild/method。在外部类中访问内部类的成员时需要先创建一个外部类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">Outter.Inner inner = outter.new Inner();<span class="comment">//必须通过 Outter 对象来创建</span></span><br></pre></td></tr></table></figure>
<p><strong>局部内部类：</strong> 定义在一个方法内部或者是一段作用域内的类，仅限于在作用域内访问</p>
<p>匿名内部类：</p>
<p><strong>静态内部类：</strong> 不依赖于外部类，不能使用外部类的非static的域或者方法</p>
<p>1、为什么成员内部类可以无条件的访问外部类的成员？</p>
<p>内部类是java的一颗语法糖，编译之后会生成两个class文件，匿名内部类名字为外部类名$x，成员内部类名字为外部类名$内部类名，编译器会默认为成员内部类添加一个参数类型为指向外部类对象的构造方法。</p>
<p>2、为什么局部内部类和匿名内部类只能访问部局部final变量？</p>
<p>比如我们在一个方法内写了一个Thread匿名内部类，当外部的方法执行完毕后，方法内的局部变量生命周期结束，而Thread对象的生命周期还没有结束，所以必须使用final修改外部类的局部变量以使它在编译阶段就被放入常量池当中</p>
<p>3、Object.this与Object.new</p>
<p>当我们需要实例化一个成员内部类的时候，可以通过OuterClass.newInnerClass的方式初始化</p>
<p>如果我们需要在内部类中生成对外部类对象的引用可以使用OuterClass.this</p>
<h2 id="8、java多态的实现原理"><a href="#8、java多态的实现原理" class="headerlink" title="8、java多态的实现原理"></a>8、java多态的实现原理</h2><p>多态就是同一个消息根据发送对象的不同而采取多种不同的行为方式。主要体现在Overload和Override上</p>
<h2 id="9、Object类都有什么方法"><a href="#9、Object类都有什么方法" class="headerlink" title="9、Object类都有什么方法"></a>9、Object类都有什么方法</h2><p>getClass(),toString(),hashCode(),clone(),wait(),notify(),notifyAll(),equals(),finalize()</p>
<p>要用想使用clone()，目标类必须实现Cloneable接口，然后以public的方式重写clone()方法，Object中原生的native方法clone()执行的是此对象的浅复制</p>
<h2 id="10、hashCode-的作用，域equals-有什么关系"><a href="#10、hashCode-的作用，域equals-有什么关系" class="headerlink" title="10、hashCode()的作用，域equals()有什么关系"></a>10、hashCode()的作用，域equals()有什么关系</h2><p>HashCode()返回该对象的hash()码值，Object()中的原生hashCode()是一个native方法，它将对象的内部地址转换成一个整数来实现。</p>
<p>HashCode()有一个常规协定：</p>
<p>1、当一个对象参与hash计算的成员域的值没有改变时，重复调用hashCode()值都相等；（一致性）</p>
<p>2、若两个对象equals()那么他们的hashCode()必须相等;</p>
<p>3、但是hashCode()相等，两个对象不一定equals()。这一点在hashMap的存储上有深刻体现。</p>
<p>Overrideequals()方法必须重写hashCode()。重写equals()要满足对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、自反性（x.equals(x)必须返回true）、一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）。</p>
<h2 id="11、深复制与浅复制区别"><a href="#11、深复制与浅复制区别" class="headerlink" title="11、深复制与浅复制区别"></a>11、深复制与浅复制区别</h2><p><strong>浅复制：</strong> 会创建一个新对象，对于源对象的基本类型属性拷贝一份，引用类型属性也只是拷贝引用。实现方式：类要重写实现Cloneable接口，以public的方式直接super重写clone()方法</p>
<p><strong>深复制：</strong> 拷贝对象所有的属性，并拷贝引用类型属性所指向的对象。实现方法：重写clone()方法自定义重写过程；</p>
<p>对象序列化</p>
<h2 id="12、说一下java异常体系"><a href="#12、说一下java异常体系" class="headerlink" title="12、说一下java异常体系"></a>12、说一下java异常体系</h2><p>Throwable是根接口，有两个子接口Error、Exception</p>
<p>不可查异常：RunTimeException、Error</p>
<p>可查异常：除不可查异常之外的Exception，比如IOException、SQLException</p>
<p>注意事项：</p>
<p>finally语句块，总会被执行，但除以下情况:</p>
<p>1、finally语句块中出现异常</p>
<p>2、前面的代码调用了System.exit()</p>
<p>当try-catch语句块中有return语句时，方法会在返回前执行finally语句中的内容</p>
<p>finally语句块中重新抛出异常会覆盖掉之前的异常，在finally中直接使用return会丢失异常。</p>
<h2 id="13、java中存在内存泄漏吗？请简单描述"><a href="#13、java中存在内存泄漏吗？请简单描述" class="headerlink" title="13、java中存在内存泄漏吗？请简单描述"></a>13、java中存在内存泄漏吗？请简单描述</h2><p>从语法层面上来说没有，因为java有垃圾会收机制，然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。</p>
<p>1、HashMap、ArrayList这一类型的集合对象，经常会导致内存泄漏，当他们被声明为static时，生命周期是和程序一样长的。所以它们引用的对象在程序的整个生命周期内都存在。</p>
<p>关于集合类还有一种情况是：当已添加到Set/Map中的对象，参与hashcode和equals()计算的变量被修改后，调用remove()无效，也会造成内存泄漏</p>
<p>2、单例模式的使用也可能导致内存泄漏，因为单例对象初始化后将在java虚拟机的整个生命周期中存在，如果他引用了一个对象，这个对象以及这个对象引用的所有对象都无法被垃圾收集器回收。</p>
<p>3、各种连接，如：dataSource、getConnection()、socket、io这些连接，JVM都不会主动回收，需要我们自己显式的在finally语句中close()</p>
<p>4、使用ThreadLocal也可能会导致内存泄漏，ThreadLocal的get()方法是从当前线程对象的ThreadLocalMap属性中获取对应的值的，ThreadLocalMap中维护着以ThreadLocal的弱引用为key的元素，当外部没有一个引用引用ThreadLocal的时候，就会被回收，这时Map中的key就为null了，这个元素也就无法被访问了，所以可能会被回收。</p>
<p>5、在使用Hibernate进行批量更新数据的时候也可能导致，因为更新数据后对象为持久态，会一直在session中存在，所以需要定期session、clear()强制清空缓存、session、flush()</p>
<h2 id="14、简述整理容器体系"><a href="#14、简述整理容器体系" class="headerlink" title="14、简述整理容器体系"></a>14、简述整理容器体系</h2><p>Stack是extendsVector的</p>
<p>LinkedHashSet、LinkedHashMap按照插入顺序排序</p>
<p>Queue:</p>
<table>
<thead>
<tr>
<th></th>
<th>在容量不足时抛异常</th>
<th>为空或容量不足时回返回false或null</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>移除</td>
<td>remove(e)</td>
<td>poll(e)</td>
</tr>
<tr>
<td>仅返回</td>
<td>element(e)</td>
<td>peek(e)</td>
</tr>
</tbody>
</table>
<h2 id="15、ArrayList、LinkedList源码分析"><a href="#15、ArrayList、LinkedList源码分析" class="headerlink" title="15、ArrayList、LinkedList源码分析"></a>15、ArrayList、LinkedList源码分析</h2><h2 id="16、HashMap、HashSet源码分析"><a href="#16、HashMap、HashSet源码分析" class="headerlink" title="16、HashMap、HashSet源码分析"></a>16、HashMap、HashSet源码分析</h2><p>Jdk7：位桶+链表</p>
<p>初始值：16最大值：2^30负载因子：0.75</p>
<p>底层数组的长度总是2^n</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry &lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; <span class="comment">//实际存储元素的地方</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<p>Entry是一个实现了Map.Entry\&lt;K,V\&gt;的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">//equals()方法：当且仅当 key 和 value 都相同时才 equals</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心构造方法：HashMap(intinitialCapacity,floatloadFactor);</p>
<p>其他的构造方法都是调用这个构造方法。</p>
<p>核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果 table 为空数组，先初始化数组</span></span><br><span class="line">    <span class="comment">//允许 key 为 null，放到 map[0]</span></span><br><span class="line">    <span class="comment">//根据 key 计算出 hash 值，然后找到这个 hash 值在数组中的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);&#125; <span class="comment">//这样保证总是在数组范围内</span></span><br><span class="line">    <span class="comment">//如果容量大于了极限则扩容为原来容量的 2 倍</span></span><br><span class="line">    <span class="comment">//取出数组中的 Entry，遍历 Entry 如果发现 key equals 则替换 value</span></span><br><span class="line">    <span class="comment">//如果 key 都不相同则在 Entry 中添加，并且位于链头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Entry放到数组的哪一个位置上是通过计算key的hashCode()得到的，当发生hash冲突(碰撞)，HashMap解决hash冲突的方式是用链表。这里要注意的是，比如A和B都hash后都映射到下标i中，之前已经有A了，当map.put(B)时，将B放到下标i中，A则为B的next，所以新值存放在数组中，旧值在新值的链表上。</p>
<p>当size大于threshold(极限值)时，会发生扩容。threshold=capacity*loadfactor（容量*负载因子），扩容为原来的22倍。</p>
<p>Jdk8：位桶+链表/红黑树</p>
<p>当某个位桶的链表的长度达到某个阀值（默认为8）的时候，这个链表就将转换成红黑树。因为链表查找的时间复杂度为O(n),而红黑树一直是O(logn)，这样会提高效率</p>
<p>HashSet：有一个HashMap成员域，所有方法直接调用HashMap中的方法。</p>
<p>如何保证元素唯一性的？</p>
<p>首先要存入的对象想要保证唯一性必须重写hashcode()和equals()方法，因为HashSet的底层实现是HashMap，Set的add()方法直接调用Map的put()方法，再解释map的put()方法</p>
<h2 id="17、List和Set区别"><a href="#17、List和Set区别" class="headerlink" title="17、List和Set区别"></a>17、List和Set区别</h2><p>它们都实现了Collection接口，List允许重复元素，并且维护一定顺序。其中ArrayList底层为数组，随机访问O(1)，但是插入和删除速度慢O(n)；LinkedList底层为双向链表，插入删除快O(1)，查找慢O(n)，LinkedList可以用作栈、队列。</p>
<p>Set不保存重复元素，HashSet使用了散列，长与查询；TreeSet将元素存储在红黑树当中，元素必须实现Comparable接口，维护特定顺序；LinkedHashSet也使用了散列，但又使用了链表来维护元素插入顺序。</p>
<h2 id="18、说一下I-O框架"><a href="#18、说一下I-O框架" class="headerlink" title="18、说一下I/O框架"></a>18、说一下I/O框架</h2><p>主要包含File类、I/O流、RandomAccessFile类(支持对文件的随机读取和写入，主要结合nio使用)</p>
<p>I/O包含字符流和字节流，各又分为输入输出两部分</p>
<p>1、字节流</p>
<p>InputStream表示从不同数据源产生的输入类：ByteArrayInputStream、StringBufferInuputStream、FileIInputStream、PipedInputStream、SequenceInputStream、FilterInputStream</p>
<p>FilterInputStream做为装饰器的接口，来控制特定的输入流：DataInputStream、BufferedInputStream、LineNumInputStream</p>
<p>OutputStream、FilterOutputStream有与输入流相对应的类PrintStream</p>
<p>2、字符流，供提供Unicode操作</p>
<p>Reader有FileReader、StringReader、CharArrayReader、PipedReader、BufferedReader</p>
<p>Writer有FileWriter、StringWriter、CharArrayWriter、PipedWriter、BufferedWriter</p>
<p>3、对象序列化</p>
<p>应用场景：web服务器中的session对象，当有10万用户访问时，服务器内存可能会吃不消了，这时可以先把session序列化到磁盘上，等到需要用的时候再序列化回来。</p>
<p>ObjectInputStream、ObjectOutputStream：用于序列化和反序列化</p>
<p>默认序列化：</p>
<p>要序列化的类必须实现Serializable接口（默认序列化）或者Externalizable（可以控制序列化的过程）</p>
<p>用于普通序列化（深复制），默认序列化恢复的时候直接从存储的二进制为基础恢复，不调用任何构造器</p>
<p>控制序列化的过程：</p>
<p>（1）序列化一个Externalizable对象会按照writeExternal()方法进行，对于恢复一个Externalizable的对象，所有普通的构造器都会被调用（包括在字段定义时的初始化），然后调用readExternal()方法。</p>
<p>（2）使用transient关键字逐个字段的关闭序列化</p>
<p>HashSet中的map就是transient的</p>
<p>注意：对于static的字段必须手动序列化，因为static的域不属于实例</p>
<p>4、压缩类</p>
<p>压缩输出类：ZipOutputStream、GZipOutputStream</p>
<p>压缩输入类：ZipInputStream、GZipInputStream</p>
<p>BufferedOutputStreamout=newBufferedOutputStream(newGZIPOutputStream(newFileOutputStream(&quot;E:/J2EE/新建文件夹/2.gz&quot;)));</p>
<p>//压缩多个文件，可是用ZipOutputStream.putNextEntry()方法</p>
<h2 id="19、java-nio"><a href="#19、java-nio" class="headerlink" title="19、java nio"></a>19、java nio</h2><p>1、与I/O的的不同点</p>
<p>（1）I/O使用的是基于流的方式，每次产生或消费一个字节的数据，速度慢、NIO实用的是基于块的传送方式每次产生或消费一个数据块，速度较快</p>
<p>（2）I/O的read()和write()方法都是阻塞的，而NIO有非阻塞模式</p>
<p>（3）NIO的Selector允许一个线程监视多个输入通道</p>
<p>2、NIO概述</p>
<p>NIO是基于Channel和Buffer的io方式，通道是对流的模拟，传送数据必须通过一个通道，向通道发送数据的时候必须先把数据放到缓冲区中，从通道中读取数据的时候也必须读到缓冲区中。</p>
<p>3、通道</p>
<p>FileChannel从文件中读写数据DatagramChannel通过UDP读写网络中数据</p>
<p>SocketChannel通过TCP读写网络中数据</p>
<p>ServerSocketChannel可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel</p>
<p>FileChannel不能切换到非阻塞模式，套接字Channel可以</p>
<p>4、缓冲区</p>
<p>ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer等。</p>
<p>Buffer的三个属性：</p>
<p>capacity：缓冲区的容量，只能往里边写入capacity个Char、Byte等</p>
<p>position、limit</p>
<p>写数据时：position指示当前的位置（初始值为0），最大值为capacity-1</p>
<p>limit表示最大能往缓冲区内写多少数据，写模式下==capacity</p>
<p>读数据时：从写切换到读时（调用flip()方法），position将会被置为0，limit表示最多能够读多少数据，从写切换到读时，limit将会被设置为写时候的position的值</p>
<p>5、使用Buffer读写数据一般步骤：</p>
<p>写入数据到Buffer调用flip()方法从Buffer中读数据调用clear()方法（会清除缓冲区）或者compact()方法（只清除读过的数据）</p>
<p>例：使用NIO读取文件中的汉字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 打开一个 fileChannel</span></span><br><span class="line">    aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"E:\\founder 实习\\temp\\nio\\testFileChannel.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">    inChannel = aFile.getChannel();</span><br><span class="line">    <span class="comment">// 建立一个容量为 80 字节的 buffer</span></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">80</span>);</span><br><span class="line">    <span class="comment">// 从 channel 写入到 buffer</span></span><br><span class="line">    <span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line">    <span class="keyword">if</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">        buf.flip(); <span class="comment">// 为读数据做好准备</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, bytesRead, <span class="string">"UTF-8"</span>));</span><br><span class="line">        buf.clear(); <span class="comment">// 清空缓冲区</span></span><br><span class="line">        bytesRead = inChannel.read(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    aFile.close();</span><br><span class="line">    inChannel.close();<span class="comment">// 关闭 fileChannel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、ServerSocketChannel</p>
<p>用于监听新进来的TCP连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">    serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        SocketChannel socketChannel = erverSocketChannel.accept();</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认为阻塞模式，serverSocketChannel.configureBlocking(false);设置为非阻塞模式，serverSocketChannel.accept();会立即返回，所以需要判断返回的socektChannel是否为null</p>
<p>7、SocketChannel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">80</span>));</span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    socketChannel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认为阻塞模式，socketChannel.configureBlocking(false);设置为非阻塞模式，在非阻塞模式下，connect()、read()、write()方法可能在没有完成的情况下就返回了，因此要在循环中调用write()使用socketChannel.finishConnect()判断连接是否建立关注read()方法的返回值</p>
<p>8、Selectors</p>
<p>一个Selector可以检测一到多个NIO通道，这样一个单独的线程就可以管理多个Channel，从而可以管理多个网络链接。因为线程之间的切换存在着很大的开销，所以使用的线程越少越好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open(); <span class="comment">// 打开选择器</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 与 selector 共同使用须为非阻塞模式</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ); <span class="comment">// 注册</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> readyChannels = selector.select();<span class="comment">// 返回就绪的通道数</span></span><br><span class="line">    <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    Set selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">    <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 一个连接已经被 serverSocket accept() 到</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">            <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// a channel is ready for reading</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// a channel is ready for writing</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20、字符编码"><a href="#20、字符编码" class="headerlink" title="20、字符编码"></a>20、字符编码</h2><p>1、iso8859-1</p>
<p>是一种单字节编码与ASCII类似，最多能表示的字符范围是0-255,应用于英文系列。</p>
<p>2、GBK</p>
<p>GB2312只能表示简体字，英文和ISO8859-1一致，GBK能够同时用来表示简体字和繁体字，兼容GB2312。他们两者都兼容ISO8859-1。是是不定长编码。</p>
<p>3、unicode</p>
<p>是一种定长编码，可用来表示所有语言的字符，为定长双字节，不兼容ISO8859-1，java内部使用Unicode来处理。</p>
<p>4、UTF-8</p>
<p>是一种多字节不定长格式，UTF-8将ASCII字符编码成单一的字节形式，将非ASCII字符编码成2-3个字节。字符串的长度存储在UTF-8字符串的前两个字节中。</p>
<h2 id="21、泛型"><a href="#21、泛型" class="headerlink" title="21、泛型"></a>21、泛型</h2><p>1、Java允许使用List等原生类型是为了向后兼容。</p>
<p>2、泛型子类型化的规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List ll;</span><br><span class="line">List&lt;Object&gt; o = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">List&lt;Integer&gt; i = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">o = i; <span class="comment">//error</span></span><br><span class="line">ll = i; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>用使用List\&lt;Objetct\&gt;与与用直接使用List的区别：后者逃避了编译器的类型检查，前者明确告诉编译器持有类型。前者不能与其它泛型的引用相互，但List的引用可以指向任意泛型的List,所以使用List\&lt;Object\&gt;更加安全。</p>
<h1 id="三、java并发"><a href="#三、java并发" class="headerlink" title="三、java并发"></a>三、java并发</h1><h2 id="1、java线程的几种状态"><a href="#1、java线程的几种状态" class="headerlink" title="1、java线程的几种状态"></a>1、java线程的几种状态</h2>
    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2018/12/07/jvm题目/" rel="prev" title="jvm题目">
                  jvm题目 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">郭世雄</p>
  <div class="site-description motion-element" itemprop="description">人生但苦无妨，良人当归即好</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、jvm题目"><span class="nav-number">1.</span> <span class="nav-text">一、jvm题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、java的内存模型"><span class="nav-number">1.1.</span> <span class="nav-text">1、java的内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、类加载的过程"><span class="nav-number">1.2.</span> <span class="nav-text">2、类加载的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、对象创建方法，对象的内存布局，对象的访问定位"><span class="nav-number">1.3.</span> <span class="nav-text">3、对象创建方法，对象的内存布局，对象的访问定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、双亲委派模型"><span class="nav-number">1.4.</span> <span class="nav-text">4、双亲委派模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、静态分派与动态分派"><span class="nav-number">1.5.</span> <span class="nav-text">5、静态分派与动态分派</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、GC的两种判定方法"><span class="nav-number">1.6.</span> <span class="nav-text">6、GC的两种判定方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、java引用都有哪几类"><span class="nav-number">1.7.</span> <span class="nav-text">7、java引用都有哪几类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、堆里面的分区各自特点"><span class="nav-number">1.8.</span> <span class="nav-text">8、堆里面的分区各自特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、常见垃圾收回算法"><span class="nav-number">1.9.</span> <span class="nav-text">9、常见垃圾收回算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、GC收集器有哪些？CMS收集器与G1收集器的特点？如果让你优化收集方法，有什么思路？"><span class="nav-number">1.10.</span> <span class="nav-text">10、GC收集器有哪些？CMS收集器与G1收集器的特点？如果让你优化收集方法，有什么思路？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、MinorGC与FullGC的触发机制"><span class="nav-number">1.11.</span> <span class="nav-text">11、MinorGC与FullGC的触发机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、几种常用的内存调试工具：jmap、jstack、jconsole"><span class="nav-number">1.12.</span> <span class="nav-text">12、几种常用的内存调试工具：jmap、jstack、jconsole</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、System-gc方法有什么用"><span class="nav-number">1.13.</span> <span class="nav-text">13、System.gc方法有什么用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14、Object-finalize方法有什么用"><span class="nav-number">1.14.</span> <span class="nav-text">14、Object.finalize方法有什么用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、javaSE题目"><span class="nav-number">2.</span> <span class="nav-text">二、javaSE题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、jdk1-7与jdk1-8的新特性"><span class="nav-number">2.1.</span> <span class="nav-text">1、jdk1.7与jdk1.8的新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、基本类型与包装类、基本类型的运算"><span class="nav-number">2.2.</span> <span class="nav-text">2、基本类型与包装类、基本类型的运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、switch是否能作用在byte、long、String上？"><span class="nav-number">2.3.</span> <span class="nav-text">3、switch是否能作用在byte、long、String上？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、String、StringBuffer、StringBuilder"><span class="nav-number">2.4.</span> <span class="nav-text">4、String、StringBuffer、StringBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、常见String比较，intern"><span class="nav-number">2.5.</span> <span class="nav-text">5、常见String比较，intern()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、请描述抽象类和接口的区别"><span class="nav-number">2.6.</span> <span class="nav-text">6、请描述抽象类和接口的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、内部类"><span class="nav-number">2.7.</span> <span class="nav-text">7、内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、java多态的实现原理"><span class="nav-number">2.8.</span> <span class="nav-text">8、java多态的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、Object类都有什么方法"><span class="nav-number">2.9.</span> <span class="nav-text">9、Object类都有什么方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、hashCode-的作用，域equals-有什么关系"><span class="nav-number">2.10.</span> <span class="nav-text">10、hashCode()的作用，域equals()有什么关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、深复制与浅复制区别"><span class="nav-number">2.11.</span> <span class="nav-text">11、深复制与浅复制区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、说一下java异常体系"><span class="nav-number">2.12.</span> <span class="nav-text">12、说一下java异常体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、java中存在内存泄漏吗？请简单描述"><span class="nav-number">2.13.</span> <span class="nav-text">13、java中存在内存泄漏吗？请简单描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14、简述整理容器体系"><span class="nav-number">2.14.</span> <span class="nav-text">14、简述整理容器体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15、ArrayList、LinkedList源码分析"><span class="nav-number">2.15.</span> <span class="nav-text">15、ArrayList、LinkedList源码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16、HashMap、HashSet源码分析"><span class="nav-number">2.16.</span> <span class="nav-text">16、HashMap、HashSet源码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17、List和Set区别"><span class="nav-number">2.17.</span> <span class="nav-text">17、List和Set区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18、说一下I-O框架"><span class="nav-number">2.18.</span> <span class="nav-text">18、说一下I/O框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19、java-nio"><span class="nav-number">2.19.</span> <span class="nav-text">19、java nio</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20、字符编码"><span class="nav-number">2.20.</span> <span class="nav-text">20、字符编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21、泛型"><span class="nav-number">2.21.</span> <span class="nav-text">21、泛型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、java并发"><span class="nav-number">3.</span> <span class="nav-text">三、java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、java线程的几种状态"><span class="nav-number">3.1.</span> <span class="nav-text">1、java线程的几种状态</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭世雄</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


</body>
</html>
